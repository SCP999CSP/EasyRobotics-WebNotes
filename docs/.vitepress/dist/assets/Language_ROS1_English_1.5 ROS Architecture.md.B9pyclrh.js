import{_ as t,c as i,o as r,af as s}from"./chunks/framework.DSuiHQgX.js";const u=JSON.parse('{"title":"1.5 ROS Architecture","description":"","frontmatter":{},"headers":[],"relativePath":"Language/ROS1/English/1.5 ROS Architecture.md","filePath":"Language/ROS1/English/1.5 ROS Architecture.md"}'),n={name:"Language/ROS1/English/1.5 ROS Architecture.md"};function o(a,e,l,c,h,p){return r(),i("div",null,[...e[0]||(e[0]=[s('<h1 id="_1-5-ros-architecture" tabindex="-1">1.5 ROS Architecture <a class="header-anchor" href="#_1-5-ros-architecture" aria-label="Permalink to “1.5 ROS Architecture”">​</a></h1><p>So far, we have installed ROS, run the built-in turtlesim demo, and written simple ROS programs, giving us a general understanding of ROS. However, this understanding might still be vague. Next, we will introduce the architectural design of ROS from a macro perspective.</p><p>The description of ROS architecture varies depending on the viewpoint. Generally, we can describe the ROS structure from four perspectives: the designers, the maintainers, the system architecture, and its own structure.</p><h2 id="_1-the-designers-perspective" tabindex="-1">1. The Designers&#39; Perspective <a class="header-anchor" href="#_1-the-designers-perspective" aria-label="Permalink to “1. The Designers&#39; Perspective”">​</a></h2><p>The ROS designers describe ROS as:<br><strong>&quot;ROS = Plumbing + Tools + Capabilities + Ecosystem&quot;</strong></p><ul><li><strong>Plumbing</strong>: Communication mechanisms (enabling interaction between different ROS nodes).</li><li><strong>Tools</strong>: Tool software packages (development and debugging tools within ROS).</li><li><strong>Capabilities</strong>: High-level robotic skills (collections of certain functions in ROS, e.g., navigation).</li><li><strong>Ecosystem</strong>: Robotic ecosystem (the ROS alliance across regions, software, and hardware).</li></ul><h2 id="_2-the-maintainers-perspective" tabindex="-1">2. The Maintainers&#39; Perspective <a class="header-anchor" href="#_2-the-maintainers-perspective" aria-label="Permalink to “2. The Maintainers&#39; Perspective”">​</a></h2><p>From the maintainers&#39; viewpoint, the ROS architecture can be divided into two main parts:</p><ul><li><strong>main</strong>: The core part, primarily designed, provided, and maintained by Willow Garage and some developers. It provides basic tools for distributed computing and programs for the core parts of ROS.</li><li><strong>universe</strong>: Global code developed and maintained by ROS community organizations from different countries. This includes library code (e.g., OpenCV, PCL); code provided from a functional perspective on the layer above libraries (e.g., face recognition, which calls lower-level libraries); and application-level code at the top layer, enabling robots to perform specific tasks.</li></ul><h2 id="_3-the-system-architecture-perspective" tabindex="-1">3. The System Architecture Perspective <a class="header-anchor" href="#_3-the-system-architecture-perspective" aria-label="Permalink to “3. The System Architecture Perspective”">​</a></h2><p>From the system architecture viewpoint, ROS can be divided into three layers:</p><ol><li><p><strong>OS Layer</strong>: The operating system in the classical sense.<br> ROS is only a meta-operating system and needs to rely on a true OS. Currently, Ubuntu Linux has the best compatibility, while Mac and Windows also support newer versions of ROS.</p></li><li><p><strong>Middleware Layer</strong>:<br> This consists of middleware for robot development encapsulated by ROS, such as:</p><ul><li>The TCPROS/UDPROS communication system, built upon TCP/UDP.</li><li>Nodelet is used for inter-process communication, supporting real-time data transmission.</li><li>Additionally, it provides a large number of libraries for robot development implementations, such as data type definitions, coordinate transformations, motion control, etc.</li></ul></li><li><p><strong>Application Layer</strong>:<br> Contains functional packages and nodes within those packages, e.g., the master, turtlesim control and motion nodes, etc.</p></li></ol><h2 id="_4-the-internal-structure-perspective" tabindex="-1">4. The Internal Structure Perspective <a class="header-anchor" href="#_4-the-internal-structure-perspective" aria-label="Permalink to “4. The Internal Structure Perspective”">​</a></h2><p>In terms of ROS&#39;s own implementation, it can also be divided into three levels:</p><ol><li><p><strong>Filesystem Level</strong>:<br> Refers to the organization of ROS source code as seen on the hard disk.</p></li><li><p><strong>Computation Graph Level</strong>:<br> Different processes in the ROS distributed system need to interact with data. The Computation Graph represents this data interaction process in a peer-to-peer network form. Important concepts include:</p><ul><li>Node</li><li>Message</li><li>Communication Mechanism - Topic</li><li>Communication Mechanism - Service</li></ul></li><li><p><strong>Open-Source Community Level</strong>:<br> This level represents the form in which code is distributed on the ROS network.</p><ul><li><strong>Distribution</strong>: A ROS Distribution is a versioned set of meta-packages that can be installed independently. They function similarly to Linux distributions, making ROS software installation easier and maintaining consistent versions across a software collection.</li><li><strong>Repository</strong>: ROS relies on websites or hosting services that share open-source code and software repositories, allowing different institutions to publish and share their robot software and programs.</li><li><strong>ROS Wiki</strong>: The primary forum for documenting information about the ROS system. Anyone can register an account, contribute documentation, provide corrections or updates, write tutorials, and more. Website: <a href="http://wiki.ros.org/" target="_blank" rel="noreferrer">http://wiki.ros.org/</a></li><li><strong>Bug Ticket System</strong>: A resource for reporting issues or suggesting new features.</li><li><strong>Mailing List</strong>: The main communication channel for ROS users, functioning like a forum for discussions ranging from ROS software updates to various questions about using ROS software. Website: <a href="http://lists.ros.org/" target="_blank" rel="noreferrer">http://lists.ros.org/</a></li><li><strong>ROS Answers</strong>: A resource for users to ask questions. Website: <a href="https://answers.ros.org/questions/" target="_blank" rel="noreferrer">https://answers.ros.org/questions/</a></li><li><strong>Blog / Community</strong>: The official ROS blog has been retired and replaced by the ROS Community for updates, photos, and news. Website: <a href="https://discourse.ros.org/" target="_blank" rel="noreferrer">https://discourse.ros.org/</a></li></ul></li></ol><hr><p>Currently, we are in the early stages of learning, having only run built-in ROS demos and written simple implementations. Therefore, limited by our progress, we will not detail all modules in the design architecture exhaustively. For now, we will focus on explaining the <strong>Filesystem</strong> and the <strong>Computation Graph</strong>. The next chapter will introduce ROS&#39;s <strong>Communication Mechanisms</strong>, which is one of the core implementations of ROS.</p>',17)])])}const g=t(n,[["render",o]]);export{u as __pageData,g as default};
