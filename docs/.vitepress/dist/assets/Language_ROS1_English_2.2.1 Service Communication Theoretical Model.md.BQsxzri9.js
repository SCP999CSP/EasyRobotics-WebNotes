import{_ as t,c as r,o as i,af as a,ay as s}from"./chunks/framework.Cf416Sfo.js";const u=JSON.parse('{"title":"2.2.1 Service Communication Theoretical Model","description":"","frontmatter":{},"headers":[],"relativePath":"Language/ROS1/English/2.2.1 Service Communication Theoretical Model.md","filePath":"Language/ROS1/English/2.2.1 Service Communication Theoretical Model.md"}'),n={name:"Language/ROS1/English/2.2.1 Service Communication Theoretical Model.md"};function o(l,e,h,c,d,m){return i(),r("div",null,[...e[0]||(e[0]=[a('<h1 id="_2-2-1-service-communication-theoretical-model" tabindex="-1">2.2.1 Service Communication Theoretical Model <a class="header-anchor" href="#_2-2-1-service-communication-theoretical-model" aria-label="Permalink to “2.2.1 Service Communication Theoretical Model”">​</a></h1><p>Service communication is somewhat simpler than topic communication. The theoretical model is shown in the figure below. This model involves three roles:</p><ul><li>ROS Master (Manager)</li><li>Server (Service Provider)</li><li>Client (Service Requester)</li></ul><p>The ROS Master is responsible for storing the registration information of Servers and Clients. It matches Servers and Clients that offer/request the same service by name and helps them establish a connection. After the connection is established, the Client sends a request message, and the Server returns a response message.</p><p><img src="'+s+'" alt="jpg"></p><p>The entire process is implemented through the following steps:</p><h4 id="_0-server-registration" tabindex="-1">0. Server Registration <a class="header-anchor" href="#_0-server-registration" aria-label="Permalink to “0. Server Registration”">​</a></h4><p>After startup, the Server registers its own information with the ROS Master via RPC, which includes the name of the service it provides. The ROS Master adds the node&#39;s registration information to its registry.</p><h4 id="_1-client-registration" tabindex="-1">1. Client Registration <a class="header-anchor" href="#_1-client-registration" aria-label="Permalink to “1. Client Registration”">​</a></h4><p>After startup, the Client also registers its own information with the ROS Master via RPC, which includes the name of the service it needs to request. The ROS Master adds the node&#39;s registration information to its registry.</p><h4 id="_2-ros-master-performs-information-matching" tabindex="-1">2. ROS Master Performs Information Matching <a class="header-anchor" href="#_2-ros-master-performs-information-matching" aria-label="Permalink to “2. ROS Master Performs Information Matching”">​</a></h4><p>The ROS Master matches Servers and Clients based on the information in its registry and sends the Server&#39;s <strong>TCP</strong> address information to the Client via RPC.</p><h4 id="_3-client-sends-request" tabindex="-1">3. Client Sends Request <a class="header-anchor" href="#_3-client-sends-request" aria-label="Permalink to “3. Client Sends Request”">​</a></h4><p>Based on the information received in step 2, the Client establishes a network connection with the Server using TCP and sends the request data.</p><h4 id="_4-server-sends-response" tabindex="-1">4. Server Sends Response <a class="header-anchor" href="#_4-server-sends-response" aria-label="Permalink to “4. Server Sends Response”">​</a></h4><p>The Server receives and parses the request data, generates a response result, and returns it to the Client.</p><blockquote><p>Note:</p><ol><li>When a client request is processed, it must be ensured that the server has already started;</li><li>Multiple servers and multiple clients can exist.</li></ol></blockquote>',17)])])}const v=t(n,[["render",o]]);export{u as __pageData,v as default};
